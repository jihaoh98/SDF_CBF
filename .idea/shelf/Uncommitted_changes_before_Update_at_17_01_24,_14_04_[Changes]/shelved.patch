Index: polytope/integral_robot/collision_avoidance.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport sdf_qp\nimport obs\nimport polytopic_robot\nimport time\nimport yaml\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.patches as mpatches\n\n\nclass Collision_Avoidance:\n    def __init__(self) -> None:\n        \"\"\" collision avoidance with obstacles \"\"\"\n        file_name = 'settings.yaml'\n        with open(file_name) as file:\n            config = yaml.safe_load(file)\n        \n        robot_params = config['robot']\n        controller_params = config['controller']\n        self.cbf_qp = sdf_qp.Sdf_Cbf_Clf()\n\n        # if no data, return N  \n        obs_params = config.get('obstacle_list')\n        cir_obs_params = config.get('cir_obstacle_list')\n        \n        # initialize the robot state, half width and height\n        self.robot_width = robot_params['width']\n        self.robot_height = robot_params['height']\n        init_state = np.array(robot_params['initial_state'])\n        # in shape (N, 2)\n        self.robot_vertexes = np.array([\n            [init_state[0] - self.robot_width, init_state[1] - self.robot_height],\n            [init_state[0] + self.robot_width, init_state[1] - self.robot_height],\n            [init_state[0] + self.robot_width, init_state[1] + self.robot_height],\n            [init_state[0] - self.robot_width, init_state[1] + self.robot_height]\n        ])\n\n        # init the robot\n        self.robot = polytopic_robot.Polytopic_robot(0, self.robot_vertexes)\n        # TODO consider orientation\n        self.robot_init_state = self.robot.init_state     \n        self.robot_cur_state = np.copy(self.robot_init_state)\n        self.robot_target_state = np.array(robot_params['target_state'])\n        self.destination_margin = robot_params['destination_margin']\n\n        # initialize the circular-shaped obstacle\n        self.cir_obs_states_list = None\n        if cir_obs_params is not None:\n            self.cir_obs_num = len(cir_obs_params['obs_states'])\n            self.cir_obs_list = [None for i in range(self.cir_obs_num)]\n            for i in range(self.cir_obs_num):\n                self.cir_obs_list[i] = obs.Circle_Obs(index=i, radius=cir_obs_params['obs_radiuses'][i], center=cir_obs_params['obs_states'][i], \n                                                vel=cir_obs_params['obs_vels'][i], mode=cir_obs_params['modes'][i])\n                            \n            # get cir_obstacles' center position and velocity as well as radius\n            self.cir_obs_init_states_list = [self.cir_obs_list[i].get_current_state() for i in range(self.cir_obs_num)]\n            self.cir_obs_states_list = np.copy(self.cir_obs_init_states_list)\n\n        # initialize the other shaped obstacle state, vertexes\n        self.obs_states_list = None\n        if obs_params is not None:\n            self.obs_num = len(obs_params['obs_vertexes'])\n            self.obs_list = [None for i in range(self.obs_num)]\n            for i in range(self.obs_num):\n                self.obs_list[i] = obs.Polytopic_Obs(index=i, vertex=obs_params['obs_vertexes'][i], \n                                                    vel=obs_params['obs_vels'][i], mode=obs_params['modes'][i])\n            # get obstacles' center position and velocity\n            self.obs_init_states_list = [self.obs_list[i].get_current_state() for i in range(self.obs_num)]\n            self.obs_states_list = np.copy(self.obs_init_states_list)\n            self.obs_init_vertexes_list = [self.obs_list[i].init_vertexes for i in range(self.obs_num)]\n\n        # controller\n        self.T = controller_params['Tmax']\n        self.step_time = controller_params['step_time']\n        self.time_steps = int(np.ceil(self.T / self.step_time))\n        self.terminal_time = self.time_steps\n\n        # storage\n        self.xt = np.zeros((3, self.time_steps + 1))\n        self.ut = np.zeros((2, self.time_steps))\n        if obs_params is not None:\n            self.obstacle_state_t = np.zeros((self.obs_num, 4, self.time_steps + 1))\n            self.obs_cbf_t = np.zeros((self.obs_num, 1, self.time_steps))\n            # for plot\n            self.obs = [None for i in range(self.obs_num)]\n        if cir_obs_params is not None:\n            self.cir_obstacle_state_t = np.zeros((self.cir_obs_num, 5, self.time_steps + 1))\n            self.cir_obs_cbf_t = np.zeros((self.cir_obs_num, 1, self.time_steps))\n            # for plot\n            self.cir_obs = [None for i in range(self.cir_obs_num)]\n\n        self.clft = np.zeros((1, self.time_steps))\n        self.slackt = np.zeros((1, self.time_steps))\n\n        # plot\n        self.fig, self.ax = plt.subplots()\n\n        # start and end state of robot\n        self.start_body = None\n        self.start_arrow = None\n        self.end_body = None\n\n        self.robot_body = None\n        self.robot_arrow = None\n        self.show_obs = True\n        \n    def navigation_destination(self):\n        \"\"\" navigate the robot to its destination \"\"\"\n        t = 0\n        process_time = []\n        # approach the destination or exceed the maximum time\n        while np.linalg.norm(self.robot_cur_state[0:2] - self.robot_target_state[0:2]) >= self.destination_margin and t - self.time_steps < 0.0:\n\n            start_time = time.time()\n            u, clf, feas = self.cbf_qp.clf_qp(self.robot_cur_state)\n            process_time.append(time.time() - start_time)\n            if not feas:\n                print('This problem is infeasible, we can not get a feasible solution!')\n                break\n            else:\n                pass\n\n            self.xt[:, t] = np.copy(self.robot_cur_state)\n            self.ut[:, t] = u\n            self.clft[:, t] = clf\n            # update the state of robot\n            self.robot_cur_state = self.cbf_qp.robot.next_state(self.robot_cur_state, u, self.step_time)\n\n            t = t + 1\n        self.terminal_time = t \n        # storage the last state of robot\n        self.xt[:, t] = np.copy(self.robot_cur_state)\n\n        self.show_obs = False\n        print('Total time: ', self.terminal_time)\n        print('Finish the solve of qp with clf!')\n        print('Average_time:', sum(process_time) / len(process_time))\n\n    def collision_avoidance(self):\n        \"\"\" solve the collision avoidance between robot and obstacles based on sdf-cbf \"\"\"\n        t = 0\n        process_time = []\n        # approach the destination or exceed the maximum time\n        while np.linalg.norm(self.robot_cur_state[0:2] - self.robot_target_state[0:2]) >= self.destination_margin and t - self.time_steps < 0.0:\n            # assign nominal controls （usually for no clf）\n            u_ref = np.array([0.0, 0.0])\n            add_clf = True\n\n            # get the current optimal controls\n            obs_vertexes_list = None\n            if self.obs_states_list is not None:\n                obs_vertexes_list = [self.obs_list[i].vertexes for i in range(self.obs_num)]\n\n            start_time = time.time()\n            u, clf, slack, feas, cbf_list, cir_cbf_list = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, self.obs_states_list, obs_vertexes_list, self.cir_obs_states_list, add_clf=add_clf, u_ref=u_ref)                                   \n            process_time.append(time.time() - start_time)\n            if not feas:\n                print('This problem is infeasible, we can not get a feasible solution!')\n                break\n            else:\n                pass\n\n            self.ut[:, t] = u\n            self.clft[:, t] = clf\n            self.slackt[:, t] = slack\n\n            # storage and update the state of robot and obstacle\n            self.xt[:, t] = np.copy(self.robot_cur_state)\n            self.robot_cur_state = self.cbf_qp.robot.next_state(self.robot_cur_state, u, self.step_time)\n            if self.obs_states_list is not None:\n                for i in range(self.obs_num):\n                    self.obs_cbf_t[i][:, t] = cbf_list[i]\n                    self.obstacle_state_t[i][:, t] = np.copy(self.obs_states_list[i])\n                    self.obs_list[i].move_forward(self.step_time)\n                self.obs_states_list = [self.obs_list[i].get_current_state() for i in range(self.obs_num)]\n\n            if self.cir_obs_states_list is not None:\n                for i in range(self.cir_obs_num):\n                    self.cir_obs_cbf_t[i][:, t] = cir_cbf_list[i]\n                    self.cir_obstacle_state_t[i][:, t] = np.copy(self.cir_obs_states_list[i])\n                    self.cir_obs_list[i].move_forward(self.step_time)\n                self.cir_obs_states_list = [self.cir_obs_list[i].get_current_state() for i in range(self.cir_obs_num)]\n            t = t + 1\n        self.terminal_time = t \n\n        # storage the last state of robot and obstacles\n        self.xt[:, t] = np.copy(self.robot_cur_state)\n        if self.obs_states_list is not None:\n            for i in range(self.obs_num):\n                self.obstacle_state_t[i][:, t] = np.copy(self.obs_states_list[i])\n        if self.cir_obs_states_list is not None:\n            for i in range(self.cir_obs_num):\n                self.cir_obstacle_state_t[i][:, t] = np.copy(self.cir_obs_states_list[i])\n\n        print('Total time: ', self.terminal_time)\n        print('Finish the solve of qp with sdf-cbf and clf!')\n        print('Average_time:', sum(process_time) / len(process_time))\n\n    def render(self):\n        \"\"\" Visualization \"\"\"\n        self.fig.set_size_inches(7, 6.5)\n        self.ax.set_aspect('equal')\n\n        # set the text in Times New Roman\n        config = {\n            \"font.family\": 'serif',\n            \"font.size\": 12,\n            \"font.serif\": ['Times New Roman'],\n            \"mathtext.fontset\": 'stix',\n        }\n        plt.rcParams.update(config)\n        self.ax.set_xlim(-5, 20.0)\n        self.ax.set_ylim(-5, 20.0)\n\n        # set the label in Times New Roman and size\n        label_font = {'family': 'Times New Roman',\n                      'weight': 'normal',\n                      'size': 16,\n                      }\n        self.ax.set_xlabel('x (m)', label_font)\n        self.ax.set_ylabel(\"y (m)\", label_font)\n\n        # set the tick in Times New Roman and size\n        self.ax.tick_params(labelsize=16)\n        labels = self.ax.get_xticklabels() + self.ax.get_yticklabels()\n        [label.set_fontname('Times New Roman') for label in labels]\n\n        self.animation_init()\n\n        # robot and the arrow\n        init_vertexes = self.robot.get_vertexes(self.robot_init_state)\n        self.robot_body = mpatches.Polygon(init_vertexes, edgecolor='silver', facecolor=None)\n        self.ax.add_patch(self.robot_body)\n\n        self.robot_arrow = mpatches.Arrow(self.robot_init_state[0],\n                                          self.robot_init_state[1],\n                                          self.robot_width * np.cos(self.robot_init_state[2]),\n                                          self.robot_width * np.sin(self.robot_init_state[2]),\n                                          width=0.15,\n                                          color='k')\n        self.ax.add_patch(self.robot_arrow)\n\n        # show obstacles\n        if self.show_obs:\n            if self.obs_states_list is not None:\n                for i in range(self.obs_num):\n                    obs_vertexes = self.obs_list[i].get_current_vertexes(self.obs_init_states_list[i])\n                    self.obs[i] = mpatches.Polygon(obs_vertexes, color='k')\n                    self.ax.add_patch(self.obs[i]) \n            if self.cir_obs_states_list is not None:\n                for i in range(self.cir_obs_num):\n                    self.cir_obs[i] = mpatches.Circle(xy=self.cir_obs_init_states_list[i][0:2], radius=self.cir_obs_init_states_list[i][4], color='k')\n                    self.ax.add_patch(self.cir_obs[i]) \n\n        self.ani = animation.FuncAnimation(self.fig,\n                                           func=self.animation_loop,\n                                           frames=self.terminal_time + 1,\n                                           init_func=self.animation_init,\n                                           interval=200,\n                                           repeat=False)\n        plt.grid('--')\n        # writergif = animation.PillowWriter(fps=30) \n        # self.ani.save('pig.gif', writer=writergif)\n\n        # writer = animation.PillowWriter(fps=15, metadata=dict(artist='Me'), bitrate=1800)\n        # self.ani.save('scatter.gif', writer=writer)\n        plt.show()\n\n    def animation_init(self):\n        \"\"\" init the robot start and end position \"\"\"\n        # start body and arrow\n        start_vertexes = self.robot.get_vertexes(self.robot_init_state)\n        self.start_body = mpatches.Polygon(start_vertexes, edgecolor='silver', facecolor=None)\n        self.ax.add_patch(self.start_body)\n        self.start_body.set_zorder(0)\n\n        self.start_arrow = mpatches.Arrow(self.robot_init_state[0],\n                                          self.robot_init_state[1], \n                                          self.robot_width * np.cos(self.robot_init_state[2]),\n                                          self.robot_width * np.sin(self.robot_init_state[2]),\n                                          width=0.15,\n                                          color='k')\n        self.ax.add_patch(self.start_arrow)\n        self.start_arrow.set_zorder(1)\n\n        # target position \n        self.end_body = mpatches.Circle((self.robot_target_state[0], self.robot_target_state[1]), radius=0.5, color='silver')\n        self.ax.add_patch(self.end_body)\n        self.end_body.set_zorder(0)\n    \n        return self.ax.patches + self.ax.texts + self.ax.artists\n\n    def animation_loop(self, indx):\n        \"\"\" loop for update the position of robot and obstacles \"\"\"\n        self.robot_body.remove()\n        self.robot_arrow.remove()\n        if self.show_obs:\n            if self.obs_states_list is not None:\n                for i in range(self.obs_num):\n                    self.obs[i].remove()\n            if self.cir_obs_states_list is not None:\n                for i in range(self.cir_obs_num):\n                    self.cir_obs[i].remove()\n\n        # add robot and arrow\n        cur_vertexes = self.robot.get_vertexes(self.xt[:, indx])\n        self.robot_body = mpatches.Polygon(cur_vertexes, edgecolor='r', facecolor=None)\n        self.ax.add_patch(self.robot_body)\n\n        self.robot_arrow = mpatches.Arrow(self.xt[:, indx][0],\n                                          self.xt[:, indx][1],\n                                          self.robot_width * np.cos(self.xt[:, indx][2]),\n                                          self.robot_width * np.sin(self.xt[:, indx][2]),\n                                          width=0.15, \n                                          color='k')\n        self.ax.add_patch(self.robot_arrow)\n\n        # add obstacles\n        if self.show_obs:\n            if self.obs_states_list is not None:\n                for i in range(self.obs_num):\n                    obs_vertexes = self.obs_list[i].get_current_vertexes(self.obstacle_state_t[i][:, indx])\n                    self.obs[i] = mpatches.Polygon(obs_vertexes, color='k')\n                    self.ax.add_patch(self.obs[i]) \n\n            if self.cir_obs_states_list is not None:\n                for i in range(self.cir_obs_num):\n                    self.cir_obs[i] = mpatches.Circle(xy=self.cir_obstacle_state_t[i][:, indx][0:2], radius=self.cir_obstacle_state_t[i][:, indx][4], color='k')\n                    self.ax.add_patch(self.cir_obs[i]) \n\n        # show past trajecotry of robot and obstacle\n        if indx != 0:\n            x_list = [self.xt[:, indx - 1][0], self.xt[:, indx][0]]\n            y_list = [self.xt[:, indx - 1][1], self.xt[:, indx][1]]\n            self.ax.plot(x_list, y_list, color='b',)\n\n            # show past trajecotry of each dynamic obstacle\n            if self.show_obs:\n                if self.obs_states_list is not None:\n                    for i in range(self.obs_num):\n                        ox_list = [self.obstacle_state_t[i][:, indx - 1][0], self.obstacle_state_t[i][:, indx][0]]\n                        oy_list = [self.obstacle_state_t[i][:, indx - 1][1], self.obstacle_state_t[i][:, indx][1]]  \n                        self.ax.plot(ox_list, oy_list, linestyle='--', color='k',)\n                if self.cir_obs_states_list is not None:\n                    for i in range(self.cir_obs_num):\n                        ox_list = [self.cir_obstacle_state_t[i][:, indx - 1][0], self.cir_obstacle_state_t[i][:, indx][0]]\n                        oy_list = [self.cir_obstacle_state_t[i][:, indx - 1][1], self.cir_obstacle_state_t[i][:, indx][1]]  \n                        self.ax.plot(ox_list, oy_list, linestyle='--', color='k',)\n\n        # plt.savefig('figure/{}.png'.format(indx), format='png', dpi=300)\n        return self.ax.patches + self.ax.texts + self.ax.artists\n\n    def show_clf(self):\n        \"\"\" show clf1\"\"\"\n        # add an extra moment   \n        t = np.arange(0, self.terminal_time / 10, self.step_time)\n        plt.plot(t, self.clft[:, 0:self.terminal_time].reshape(self.terminal_time), linewidth=3, color='grey')\n\n        # set the label in Times New Roman and size\n        label_font = {'family': 'Times New Roman',\n                      'weight': 'normal',\n                      'size': 16,\n                      }\n        plt.title('CLF', label_font)\n        plt.ylabel('clf ', label_font)\n        plt.xlabel('Time (s)', label_font)\n\n        # set the tick in Times New Roman and size\n        self.ax.tick_params(labelsize=16)\n        labels = self.ax.get_xticklabels() + self.ax.get_yticklabels()\n        [label.set_fontname('Times New Roman') for label in labels]\n\n        plt.grid() \n        # plt.savefig('state_v.png', format='png', dpi=300)\n        plt.show()\n        plt.close(self.fig)\n\n    def show_cbf(self):\n        \"\"\" show cbf \"\"\"\n        # add an extra moment   \n        t = np.arange(0, self.terminal_time / 10, self.step_time)\n        plt.plot(t, self.obs_cbf_t[0][:, 0:self.terminal_time].reshape(self.terminal_time), linewidth=3, color='grey')\n\n        # set the label in Times New Roman and size\n        label_font = {'family': 'Times New Roman',\n                      'weight': 'normal',\n                      'size': 16,\n                      }\n        plt.title('SDF with respect to Circle', label_font)\n        plt.ylabel('cbf ', label_font)\n        plt.xlabel('Time (s)', label_font)\n\n        # set the tick in Times New Roman and size\n        self.ax.tick_params(labelsize=16)\n        labels = self.ax.get_xticklabels() + self.ax.get_yticklabels()\n        [label.set_fontname('Times New Roman') for label in labels]\n\n        plt.grid() \n        # plt.savefig('state_v.png', format='png', dpi=300)\n        plt.show()\n        plt.close(self.fig)\n\n    def show_cir_cbf(self):\n        \"\"\" show cbf \"\"\"\n        # add an extra moment   \n        t = np.arange(0, self.terminal_time / 10, self.step_time)\n        plt.plot(t, self.cir_obs_cbf_t[0][:, 0:self.terminal_time].reshape(self.terminal_time), linewidth=3, color='grey')\n\n        # set the label in Times New Roman and size\n        label_font = {'family': 'Times New Roman',\n                      'weight': 'normal',\n                      'size': 16,\n                      }\n        plt.title('SDF with respect to Polytope', label_font)\n        plt.ylabel('cbf ', label_font)\n        plt.xlabel('Time (s)', label_font)\n\n        # set the tick in Times New Roman and size\n        self.ax.tick_params(labelsize=16)\n        labels = self.ax.get_xticklabels() + self.ax.get_yticklabels()\n        [label.set_fontname('Times New Roman') for label in labels]\n\n        plt.grid() \n        # plt.savefig('state_v.png', format='png', dpi=300)\n        plt.show()\n        plt.close(self.fig)\n\nif __name__ == '__main__':\n    test_target = Collision_Avoidance()\n    # test_target.navigation_destination()\n    test_target.collision_avoidance()\n    test_target.render()\n    # test_target.show_cbf()\n    # test_target.show_clf()
===================================================================
diff --git a/polytope/integral_robot/collision_avoidance.py b/polytope/integral_robot/collision_avoidance.py
--- a/polytope/integral_robot/collision_avoidance.py	
+++ b/polytope/integral_robot/collision_avoidance.py	
@@ -432,4 +432,4 @@
     test_target.collision_avoidance()
     test_target.render()
     # test_target.show_cbf()
-    # test_target.show_clf()
\ No newline at end of file
+    test_target.show_clf()
\ No newline at end of file
Index: polytope/integral_robot/settings.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>controller:\n  Tmax: 20\n  step_time: 0.1\n  weight_input: [1.0, 1.0]\n  smooth_input: [1.0, 0.5]\n  weight_slack: 100\n  clf_lambda: 0.75\n  cbf_gamma: 1.0 \n\nrobot:\n  u_max: [2.0, 2.0]\n  u_min: [-2.0, -2.0]\n  initial_state: [5.0, 9.5, 0.0]\n  target_state: [15.0, 9.5, 0.0]\n  destination_margin: 0.1\n  width: 1.0  # half\n  height: 0.5  # half\n  sensor_range: 6.0\n  margin: 0.1\n  e0: 1e-6\n  \n# cir_obstacle_list:\n#   obs_states: [\n#     [6.0, 9.0]\n#   ]\n#   obs_radiuses: [0.85]\n#   obs_vels: [\n#     [0.0, 0.0]\n#   ]\n#   modes: [\n#     'static'\n#   ]\n\nobstacle_list:\n  obs_vertexes: [\n    [[8.0, 11.0], [11.0, 11.0], [11.0, 12.5], [8.0, 12.5]]\n  ]\n  obs_vels: [\n    [0.0, -0.5]\n  ]\n  modes: [\n    'dynamic'\n  ]\n  # obs_vertexes: [\n  #   [[9.0, 10.3], [12.0, 10.3], [12.0, 12.0], [9.0, 12.0]],\n  #   [[9.0, 7.0], [12.0, 7.0], [12.0, 8.8], [9.0, 8.8]]\n  # ]\n  # obs_vels: [\n  #   [0.0, 0.0],  \n  #   [0.0, 0.0]\n  # ]\n  # modes: [\n  #   'static', 'static'\n  # ]\n
===================================================================
diff --git a/polytope/integral_robot/settings.yaml b/polytope/integral_robot/settings.yaml
--- a/polytope/integral_robot/settings.yaml	
+++ b/polytope/integral_robot/settings.yaml	
@@ -10,37 +10,37 @@
 robot:
   u_max: [2.0, 2.0]
   u_min: [-2.0, -2.0]
-  initial_state: [5.0, 9.5, 0.0]
-  target_state: [15.0, 9.5, 0.0]
+  initial_state: [1.0, 7.5, 0.0]
+  target_state: [15.0, 9.3, 0.0]
   destination_margin: 0.1
-  width: 1.0  # half
-  height: 0.5  # half
+  width: 0.1  # half
+  height: 0.05  # half
   sensor_range: 6.0
   margin: 0.1
   e0: 1e-6
   
-# cir_obstacle_list:
-#   obs_states: [
-#     [6.0, 9.0]
-#   ]
-#   obs_radiuses: [0.85]
-#   obs_vels: [
-#     [0.0, 0.0]
-#   ]
-#   modes: [
-#     'static'
-#   ]
-
-obstacle_list:
-  obs_vertexes: [
-    [[8.0, 11.0], [11.0, 11.0], [11.0, 12.5], [8.0, 12.5]]
+cir_obstacle_list:
+  obs_states: [
+    [6.0, 9.5]
   ]
+  obs_radiuses: [0.85]
   obs_vels: [
-    [0.0, -0.5]
+    [0.0, 0.0]
   ]
   modes: [
-    'dynamic'
+    'static'
   ]
+
+#obstacle_list:
+#  obs_vertexes: [
+#    [[8.0, 11.0], [11.0, 11.0], [11.0, 12.5], [8.0, 12.5]]
+#  ]
+#  obs_vels: [
+#    [0.0, -0.5]
+#  ]
+#  modes: [
+#    'dynamic'
+#  ]
   # obs_vertexes: [
   #   [[9.0, 10.3], [12.0, 10.3], [12.0, 12.0], [9.0, 12.0]],
   #   [[9.0, 7.0], [12.0, 7.0], [12.0, 8.8], [9.0, 8.8]]
