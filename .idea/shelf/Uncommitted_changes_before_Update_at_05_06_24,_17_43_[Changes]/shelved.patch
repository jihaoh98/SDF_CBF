Index: point_mass/collision_avoidance.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nfrom integral_sdf_qp import Integral_Sdf_Cbf_Clf\nimport time\nimport yaml\nimport obs\nfrom render_show import Render_Animation\nimport statistics\nfrom cdf import CDF2D\nfrom primitives2D_torch import Circle\nimport torch\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\n\nclass Collision_Avoidance:\n    def __init__(self, file_name) -> None:\n        \"\"\" collision avoidance with obstacles \"\"\"\n        with open(file_name) as file:  # Use file to refer to the file object\n            config = yaml.safe_load(file)  # Load YAML file into Python dict\n\n        robot_params = config['robot']\n        controller_params = config['controller']\n        self.cbf_qp = Integral_Sdf_Cbf_Clf(file_name)\n\n        # init robot state\n        self.robot_init_state = np.array(robot_params['initial_state'])\n        self.robot_cur_state = np.copy(self.robot_init_state)\n        self.robot_target_state = np.array(robot_params['target_state'])\n        self.destination_margin = robot_params['destination_margin']\n        self.margin = robot_params['margin']\n\n        # init obstacle, if no data, return None\n        cir_obs_params = config.get('cir_obstacle_list')\n        self.cir_obs_states_list = None\n        if cir_obs_params is not None:\n            self.cir_obs_num = len(cir_obs_params['obs_states'])\n            self.cir_obs_list = [None for i in range(self.cir_obs_num)]\n            for i in range(self.cir_obs_num):\n                self.cir_obs_list[i] = obs.Circle_Obs(\n                    index=i,\n                    radius=cir_obs_params['obs_radiuses'][i],\n                    center=cir_obs_params['obs_states'][i],\n                    vel=cir_obs_params['obs_vels'][i],\n                    mode=cir_obs_params['modes'][i],\n                )\n\n            # get cir_obstacles' center position and velocity as well as radius\n            self.cir_obs_init_states_list = [\n                self.cir_obs_list[i].get_current_state() for i in range(self.cir_obs_num)\n            ]\n            self.cir_obs_states_list = np.copy(self.cir_obs_init_states_list)\n\n        # controller\n        self.T = controller_params['Tmax']\n        self.step_time = controller_params['step_time']\n        self.time_steps = int(np.ceil(self.T / self.step_time))\n        self.terminal_time = self.time_steps\n\n        # storage\n        self.xt = np.zeros((3, self.time_steps + 1))\n        self.ut = np.zeros((2, self.time_steps))\n        self.clft = np.zeros((1, self.time_steps))\n        self.slackt = np.zeros((1, self.time_steps))\n\n        self.cir_obstacle_state_t = None\n        self.cir_obs_cbf_t = None\n        if cir_obs_params is not None:\n            self.cir_obstacle_state_t = np.zeros((self.cir_obs_num, 5, self.time_steps + 1))\n            self.cir_obs_cbf_t = np.zeros((self.cir_obs_num, self.time_steps))\n\n        # plot\n        self.ani = Render_Animation(\n            robot_params,\n            cir_obs_params,\n            self.step_time,\n        )\n        self.show_obs = True\n\n    def navigation_destination(self, add_slack=False):\n        \"\"\" navigate the robot to its destination \"\"\"\n        t = 0\n        process_time = []\n        # approach the destination or exceed the maximum time\n        while (\n                np.linalg.norm(self.robot_cur_state[0:2] - self.robot_target_state[0:2])\n                >= self.destination_margin\n                and t - self.time_steps < 0.0\n        ):\n            if t % 100 == 0:\n                print(f't = {t}')\n\n            start_time = time.time()\n            optimal_result = self.cbf_qp.clf_qp(self.robot_cur_state, add_slack=add_slack)\n            process_time.append(time.time() - start_time)\n\n            if not optimal_result.feas:\n                print('This problem is infeasible, we can not get a feasible solution!')\n                break\n            else:\n                pass\n\n            self.xt[:, t] = np.copy(self.robot_cur_state)\n            self.ut[:, t] = optimal_result.u\n            self.clft[0, t] = optimal_result.clf\n\n            # update the state of robot\n            self.robot_cur_state = self.cbf_qp.robot.next_state(self.robot_cur_state, optimal_result.u, self.step_time)\n            t = t + 1\n\n        self.terminal_time = t\n        # storage the last state of robot\n        self.xt[:, t] = np.copy(self.robot_cur_state)\n        self.show_obs = False\n\n        print('Total time: ', self.terminal_time)\n        if np.linalg.norm(self.robot_cur_state[0:2] - self.robot_target_state[0:2]) <= self.destination_margin:\n            print('Robot has arrived its destination!')\n        else:\n            print('Robot has not arrived its destination!')\n        print('Finish the solve of QP with clf!')\n\n        print('Maxinum_time:', max(process_time))\n        print('Minimum_time:', min(process_time))\n        print('Median_time:', statistics.median(process_time))\n        print('Average_time:', statistics.mean(process_time))\n\n    def collision_avoidance(self, add_clf=True, cdf=None):\n        \"\"\" solve the collision avoidance between robot and obstacles based on sdf-cbf \"\"\"\n        t = 0  # set the initial time\n        process_time = []\n\n        # load the neural network model to get the distance and gradient to the obstacle\n        object_center = [torch.tensor([2.5, -2.5])]\n        cdf.obj_lists = [Circle(center=object_center[0], radius=0.3, device=device)]\n\n        # obstacle states\n        obs_state = np.array([2.5, -2.5, 0, 0, 0.0])\n\n        # approach the destination or exceed the maximum time\n        while (\n                np.linalg.norm(self.robot_cur_state[0:2] - self.robot_target_state[0:2])\n                >= self.destination_margin\n                and t - self.time_steps < 0.0\n        ):\n            if t % 100 == 0:\n                print(f't = {t}')\n\n            start_time = time.time()\n            # start to solve the qp problem\n            # optimal_result = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, self.cir_obs_states_list, add_clf=add_clf)\n            distance_input, gradient_input = cdf.inference_c_space_sdf_using_data(\n                torch.from_numpy(self.robot_cur_state[:2]).to(device).reshape(1, 2))\n\n            distance_input = distance_input.cpu().detach().numpy()\n            gradient_input = gradient_input.cpu().detach().numpy()\n\n            distance_input = distance_input - self.margin\n            optimal_result = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, distance_input, gradient_input,\n                                                    obs_state, add_clf=add_clf)\n            process_time.append(time.time() - start_time)\n\n            if not optimal_result.feas:\n                print('This problem is infeasible, we can not get a feasible solution!')\n                break\n            else:\n                pass\n\n            self.ut[:, t] = optimal_result.u\n            self.clft[0, t] = optimal_result.clf\n            self.slackt[0, t] = optimal_result.slack\n\n            # storage and update the state of robot and obstacle\n            self.xt[:, t] = np.copy(self.robot_cur_state)\n\n            self.robot_cur_state = self.cbf_qp.robot.next_state(self.robot_cur_state, optimal_result.u, self.step_time)\n\n            if self.cir_obs_states_list is not None:\n                self.cir_obs_cbf_t[:, t] = optimal_result.cir_cbf_list[0]\n                for i in range(self.cir_obs_num):\n                    self.cir_obstacle_state_t[i][:, t] = np.copy(self.cir_obs_states_list[i])\n                    self.cir_obs_list[i].move_forward(self.step_time)\n                self.cir_obs_states_list = [self.cir_obs_list[i].get_current_state() for i in range(self.cir_obs_num)]\n            t = t + 1\n\n        self.terminal_time = t\n\n        # storage the last state of robot and obstacles\n        self.xt[:, t] = np.copy(self.robot_cur_state)\n        if self.cir_obs_states_list is not None:\n            for i in range(self.cir_obs_num):\n                self.cir_obstacle_state_t[i][:, t] = np.copy(self.cir_obs_states_list[i])\n\n        print('Total time: ', self.terminal_time)\n        if np.linalg.norm(self.robot_cur_state[0:2] - self.robot_target_state[0:2]) <= self.destination_margin:\n            print('Robot has arrived its destination!')\n        else:\n            print('Robot has not arrived its destination!')\n        print('Finish the solve of QP with clf and cbf!')\n\n        print('Maxinum_time:', max(process_time))\n        print('Minimum_time:', min(process_time))\n        print('Median_time:', statistics.median(process_time))\n        print('Average_time:', statistics.mean(process_time))\n\n    def render(self, cdf=None):\n        self.ani.render(self.xt, self.cir_obstacle_state_t, self.terminal_time, self.show_obs, cdf)\n\n    def show_cbf(self, i):\n        self.ani.show_cbf(i, self.cir_obs_cbf_t, self.terminal_time)\n\n    def show_controls(self):\n        self.ani.show_integral_controls(self.ut, self.terminal_time)\n\n    def show_clf(self):\n        self.ani.show_clf(self.clft[0], self.terminal_time)\n\n    def show_slack(self):\n        self.ani.show_slack(self.slackt[0], self.terminal_time)\n\n    def show_robot(self):\n        self.ani.plot_2d_manipulators(joint_angles_batch=(self.xt[0:2, :self.terminal_time]).reshape(-1, 2))\n\n\nif __name__ == '__main__':\n    # file_name = 'dynamic_setting.yaml'\n    file_name = 'static_setting.yaml'\n\n    # load the neural network model to get the distance and gradient to the obstacle\n    cdf = CDF2D(device)\n\n    test_target = Collision_Avoidance(file_name)\n    # test_target.navigation_destination()\n\n    test_target.collision_avoidance(cdf=cdf)\n    test_target.render(cdf=cdf)\n    # test_target.show_controls()\n    # test_target.show_clf()\n    # test_target.show_slack()\n    # test_target.show_cbf(0)\n    test_target.show_robot()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/point_mass/collision_avoidance.py b/point_mass/collision_avoidance.py
--- a/point_mass/collision_avoidance.py	
+++ b/point_mass/collision_avoidance.py	
@@ -130,11 +130,11 @@
         process_time = []
 
         # load the neural network model to get the distance and gradient to the obstacle
-        object_center = [torch.tensor([2.5, -2.5])]
-        cdf.obj_lists = [Circle(center=object_center[0], radius=0.3, device=device)]
+        # object_center = [torch.tensor([2.5, -2.5])]  # static obstacle
+        # cdf.obj_lists = [Circle(center=object_center[0], radius=0.3, device=device)]
 
         # obstacle states
-        obs_state = np.array([2.5, -2.5, 0, 0, 0.0])
+        # obs_state = np.array([2.5, -2.5, 0., 0., 0.])
 
         # approach the destination or exceed the maximum time
         while (
@@ -145,18 +145,19 @@
             if t % 100 == 0:
                 print(f't = {t}')
 
+            object_center = np.array([2.5, -2.5, 0.0, 0.0])
             start_time = time.time()
             # start to solve the qp problem
-            # optimal_result = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, self.cir_obs_states_list, add_clf=add_clf)
-            distance_input, gradient_input = cdf.inference_c_space_sdf_using_data(
-                torch.from_numpy(self.robot_cur_state[:2]).to(device).reshape(1, 2))
+            optimal_result = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, self.cir_obs_states_list, add_clf=add_clf)
+            # distance_input, gradient_input = cdf.inference_c_space_sdf_using_data(
+            #     torch.from_numpy(self.robot_cur_state[:2]).to(device).reshape(1, 2))
 
-            distance_input = distance_input.cpu().detach().numpy()
-            gradient_input = gradient_input.cpu().detach().numpy()
+            # distance_input = distance_input.cpu().detach().numpy()
+            # gradient_input = gradient_input.cpu().detach().numpy()
 
-            distance_input = distance_input - self.margin
-            optimal_result = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, distance_input, gradient_input,
-                                                    obs_state, add_clf=add_clf)
+            # distance_input = distance_input - self.margin
+            # optimal_result = self.cbf_qp.cbf_clf_qp(self.robot_cur_state, distance_input, gradient_input,
+            #                                         obs_state, add_clf=add_clf)
             process_time.append(time.time() - start_time)
 
             if not optimal_result.feas:
@@ -236,5 +237,5 @@
     # test_target.show_controls()
     # test_target.show_clf()
     # test_target.show_slack()
-    # test_target.show_cbf(0)
-    test_target.show_robot()
+    test_target.show_cbf(0)
+    # test_target.show_robot()
Index: point_mass/integral_sdf_qp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport casadi as ca\nimport integral_robot_sdf\nimport yaml\nimport time\n\n\nclass Integral_Sdf_Cbf_Clf:\n    def __init__(self, file_name) -> None:\n        \"\"\" init the optimal problem with clf-cbf-qp \"\"\"\n        with open(file_name) as file:\n            config = yaml.safe_load(file)\n\n        controller_params = config['controller']\n        robot_params = config['robot']\n\n        # init robot\n        self.robot = integral_robot_sdf.Integral_Robot_Sdf(robot_params)\n        self.state_dim = self.robot.state_dim\n        self.control_dim = self.robot.control_dim\n        self.target_state = robot_params['target_state']\n        self.sensor_range = robot_params['sensor_range']\n        self.robot_radius = robot_params['radius']\n\n        # initialize CLF \n        self.clf = self.robot.clf\n        self.lf_clf = self.robot.lf_clf\n        self.lg_clf = self.robot.lg_clf\n\n        # initialize CBF\n        self.cbf = self.robot.cbf\n        self.lf_cbf = self.robot.lf_cbf\n        self.lg_cbf = self.robot.lg_cbf\n        self.dt_cbf = self.robot.dt_cbf\n\n        # get the parameter for optimal control\n        self.weight_input = controller_params['weight_input']\n        self.smooth_input = controller_params['smooth_input']\n        self.weight_slack = controller_params['weight_slack']\n        self.clf_lambda = controller_params['clf_lambda']\n        self.cbf_gamma = controller_params['cbf_gamma']\n\n        # boundary of control variables\n        self.u_max = robot_params['u_max']\n        self.u_min = robot_params['u_min']\n\n        # optimize and set the solver\n        # ipopt\n        # self.opti = ca.Opti()\n        # opts_setting = {\n        #         'ipopt.max_iter': 100,\n        #         'ipopt.print_level': 0,\n        #         'print_time': 0,\n        #         'ipopt.acceptable_tol': 1e-8,\n        #         'ipopt.acceptable_obj_change_tol': 1e-6\n        #     }\n        # self.opti.solver('ipopt', opts_setting)\n\n        # qpoases\n        self.opti = ca.Opti('conic')\n        opts_setting = {\n            'printLevel': 'low',\n            'error_on_fail': False,\n            'expand': True,\n            'print_time': 0\n        }\n        self.opti.solver('qpoases', opts_setting)  # set the controller\n\n        self.u = self.opti.variable(self.control_dim)\n        self.slack = self.opti.variable()\n        self.obj = None\n\n        # approach the desired control and smooth the control\n        self.H = np.diag(self.weight_input)\n        self.R = np.diag(self.smooth_input)\n\n    def set_optimal_function(self, u_ref, add_slack=True):\n        \"\"\" set the optimal function \"\"\"\n        self.obj = (self.u - u_ref).T @ self.H @ (self.u - u_ref)\n        if add_slack:\n            self.obj = self.obj + self.weight_slack * self.slack ** 2\n        self.opti.minimize(self.obj)\n        self.opti.subject_to()\n\n    def add_clf_cons(self, robot_cur_state, add_slack=True):\n        \"\"\" add clf cons \"\"\"\n        clf = self.clf(robot_cur_state, self.target_state)\n        lf_clf = self.lf_clf(robot_cur_state, self.target_state)\n        lg_clf = self.lg_clf(robot_cur_state, self.target_state)\n\n        if add_slack:\n            self.opti.subject_to(lf_clf + (lg_clf @ self.u)[0, 0] + self.clf_lambda * clf <= self.slack)\n            self.opti.subject_to(self.opti.bounded(-np.inf, self.slack, np.inf))\n        else:\n            self.opti.subject_to(lf_clf + (lg_clf @ self.u)[0, 0] + self.clf_lambda * clf <= 0)\n\n        return clf\n\n    def add_controls_physical_cons(self):\n        \"\"\" add physical constraint of controls \"\"\"\n        self.opti.subject_to(self.opti.bounded(self.u_min, self.u, self.u_max))\n\n    def add_cdf_cbf_cons(self, robot_state, obs_state, dist_input, grad_input):\n        \"\"\" add cons w.r.t cdf obstacle \"\"\"\n        obs_cur_point_state = np.array([obs_state[0], obs_state[1], 0, 0])\n        cbf = dist_input  # the distance between robot and obstacle\n        lf_cbf, lg_cbf, dt_obs_cbf = self.robot.derive_cbf_gradient(robot_state, obs_state, dist_input, grad_input)\n        self.opti.subject_to(lf_cbf + (lg_cbf @ self.u)[0, 0] + dt_obs_cbf + self.cbf_gamma * cbf >= 0)\n        return cbf\n\n    def add_cir_cbf_cons(self, robot_state_cbf, cir_obs_state):\n        \"\"\" add cons w.r.t circle obstacle \"\"\"\n        cbf = self.cbf(robot_state_cbf, cir_obs_state)\n        lf_cbf = self.lf_cbf(robot_state_cbf, cir_obs_state)\n        lg_cbf = self.lg_cbf(robot_state_cbf, cir_obs_state)\n        dt_cbf = self.dt_cbf(robot_state_cbf, cir_obs_state)\n\n        self.opti.subject_to(lf_cbf + (lg_cbf @ self.u)[0, 0] + dt_cbf + self.cbf_gamma * cbf >= 0)\n        return cbf\n\n    def clf_qp(self, robot_cur_state, add_slack=False, u_ref=None):\n        \"\"\" \n        calculate the optimal control which navigating the robot to its destination\n        Args: \n            robot_cur_state: [x, y, theta] np.array(3, )\n            u_ref: None or np.array(2, )\n        Returns:\n            optimal control u\n        \"\"\"\n        if u_ref is None:\n            u_ref = np.zeros(self.control_dim)\n\n        self.set_optimal_function(u_ref, add_slack)\n        clf = self.add_clf_cons(robot_cur_state, add_slack)\n        self.add_controls_physical_cons()\n\n        # result\n        result = lambda: None\n        result.clf = clf\n\n        # optimize the qp problem\n        try:\n            start_time = time.time()\n            sol = self.opti.solve()\n            end_time = time.time()\n            optimal_control = sol.value(self.u)\n\n            result.u = optimal_control\n            result.time = end_time - start_time\n            result.feas = True\n        except:\n            print(self.opti.return_status() + ' clf qp')\n            result.u = None\n            result.time = None\n            result.feas = False\n\n        return result\n\n    def cbf_clf_qp(self, robot_cur_state, dist_input=None, grad_input=None, cdf_obs_state=None, add_clf=True,\n                   u_ref=None):\n        \"\"\"\n        This is a function to calculate the optimal control for the robot w.r.t circular-shaped obstacles\n        Args:\n            robot_cur_state: [x, y, theta] np.array(3, )\n            cir_obs_state: [ox, oy, ovx, ovy, o_radius] list for circle obstacle state\n            robot_state_cbf: [x, y, theta, radius] np.array(4, )\n        Returns:\n            optimal control u\n        \"\"\"\n        if u_ref is None:\n            u_ref = np.zeros(self.control_dim)\n        self.set_optimal_function(u_ref, add_slack=add_clf)\n\n        clf = None\n        if add_clf:\n            clf = self.add_clf_cons(robot_cur_state, add_slack=add_clf)\n\n        # # add cbf constraints for each circular-shaped obstacles\n        # cir_cbf_list = None\n        # robot_state_cbf = np.hstack((robot_cur_state, np.array([self.robot_radius])))\n        # if cir_obs_states is not None:\n        #     cir_cbf_list = []\n        #     for cir_obs_state in cir_obs_states:\n        #         cbf = self.add_cir_cbf_cons(robot_state_cbf, cir_obs_state)\n        #         cir_cbf_list.append(cbf)  # for visualization\n\n        # add cdf_cbf constraints for the collision avoidance between robot and obstacles\n        cdf_cbf_list = None\n        if cdf_obs_state is not None:\n            cdf_cbf_list = []\n            cdf_cbf = self.add_cdf_cbf_cons(robot_cur_state, cdf_obs_state, dist_input, grad_input)\n            cdf_cbf_list.append(cdf_cbf)\n\n        self.add_controls_physical_cons()\n\n        # result\n        result = lambda: None\n        result.clf = clf\n        result.cir_cbf_list = cdf_cbf_list\n\n        # optimize the qp problem\n        try:\n            start_time = time.time()\n            sol = self.opti.solve()\n            end_time = time.time()\n            optimal_control = sol.value(self.u)\n\n            result.u = optimal_control\n            result.time = end_time - start_time\n            result.feas = True\n\n            if add_clf:\n                slack = sol.value(self.slack)\n                result.slack = slack\n            else:\n                result.slack = None\n        except:\n            print(self.opti.return_status() + ' sdf-cbf with clf')\n            result.u = None\n            result.time = None\n            result.feas = False\n            result.slack = None\n\n        return result\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/point_mass/integral_sdf_qp.py b/point_mass/integral_sdf_qp.py
--- a/point_mass/integral_sdf_qp.py	
+++ b/point_mass/integral_sdf_qp.py	
@@ -176,13 +176,13 @@
             clf = self.add_clf_cons(robot_cur_state, add_slack=add_clf)
 
         # # add cbf constraints for each circular-shaped obstacles
-        # cir_cbf_list = None
-        # robot_state_cbf = np.hstack((robot_cur_state, np.array([self.robot_radius])))
-        # if cir_obs_states is not None:
-        #     cir_cbf_list = []
-        #     for cir_obs_state in cir_obs_states:
-        #         cbf = self.add_cir_cbf_cons(robot_state_cbf, cir_obs_state)
-        #         cir_cbf_list.append(cbf)  # for visualization
+        cir_cbf_list = None
+        robot_state_cbf = np.hstack((robot_cur_state, np.array([self.robot_radius])))
+        if cir_obs_states is not None:
+            cir_cbf_list = []
+            for cir_obs_state in cir_obs_states:
+                cbf = self.add_cir_cbf_cons(robot_state_cbf, cir_obs_state)
+                cir_cbf_list.append(cbf)  # for visualization
 
         # add cdf_cbf constraints for the collision avoidance between robot and obstacles
         cdf_cbf_list = None
Index: point_mass/static_setting.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>controller:\n  Tmax: 20\n  step_time: 0.1\n  weight_input: [1.0, 1.0]\n  smooth_input: [1.0, 0.5]\n  weight_slack: 100\n  clf_lambda: 1.0\n  cbf_gamma: 0.8\n\nrobot:\n  u_max: [3.0, 3.0]\n  u_min: [-3.0, -3.0]\n  initial_state: [-2.5, -2.5, 0.0]\n  target_state: [2.5, 2.5, 0.0]\n  radius: 0.001\n  destination_margin: 0.1\n  sensor_range: 6.0\n  margin: 0.01\n  \ncir_obstacle_list:\n  obs_states: [\n    [2.5, -2.5]\n  ]\n  obs_radiuses: [0.3]\n  obs_vels: [\n    [0.0, 0.0]\n  ]\n  modes: [\n    'static'\n  ]\n\n#  cdf_obstacle_list:\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/point_mass/static_setting.yaml b/point_mass/static_setting.yaml
--- a/point_mass/static_setting.yaml	
+++ b/point_mass/static_setting.yaml	
@@ -1,6 +1,6 @@
 controller:
   Tmax: 20
-  step_time: 0.1
+  step_time: 0.05
   weight_input: [1.0, 1.0]
   smooth_input: [1.0, 0.5]
   weight_slack: 100
@@ -10,12 +10,12 @@
 robot:
   u_max: [3.0, 3.0]
   u_min: [-3.0, -3.0]
-  initial_state: [-2.5, -2.5, 0.0]
+  initial_state: [-2.5, -0.5, 0.0]
   target_state: [2.5, 2.5, 0.0]
   radius: 0.001
   destination_margin: 0.1
   sensor_range: 6.0
-  margin: 0.01
+  margin: 0.65
   
 cir_obstacle_list:
   obs_states: [
